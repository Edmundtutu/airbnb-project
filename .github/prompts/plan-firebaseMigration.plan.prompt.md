## Plan: Firebase Chat Migration

Replace the Laravel/Echo chat stack with a Firebase Realtime Database solution aligned to booking-centric workflows. We will inventory and remove legacy backend/frontend chat code, introduce Firebase configuration and services, define booking-scoped data structures, rebuild React contexts/components atop the new data layer, and ensure secure auth/role enforcement plus booking linkage remains intact.

### Current Pain & Frustration Points
1. **Backend schema drift and noisy queries:** The Laravel migrations/models/events assume ULID messages, polymorphic senders, and read flags, yet client code expects simpler payloads. Every dialog open cascades through `ensureConversationForBooking`, `loadMessages`, `markAsRead`, and multiple broadcast subscriptions, duplicating work and hammering the database with redundant joins and pagination.
2. **Frontend state fragmentation:** `ChatContext`, `MultiChatContext`, and `realtime.ts` all maintain their own sockets, polling loops, and optimistic updates. Error boundaries sprinkled across `ChatDialog`, `ChatManager`, and `ChatLauncher` indicate brittle coupling and an inability to reliably know whether sockets are connected.
3. **Polling instead of true realtime:** Conversation lists refresh every few seconds through REST even while Echo is connected, so bandwidth burns without delivering fresher data. Typing indicators also use REST endpoints per keystroke, adding latency and unnecessary server load.
4. **Subscription churn and race conditions:** Switching between chats destroys and recreates the Echo channel for each conversation. When multiple windows are open, messages can arrive out of order, and failures in the broadcaster mean the UI shows no sent message until the next poll.
5. **Operational complexity:** The stack depends on broadcasting configs (Pusher/Reverb), queue workers, presence channels, and custom diagnostics tooling just to keep chats alive. Debugging involves both Laravel logs and frontend socket traces, slowing feature work.

### Migration Approach
1. **Full legacy audit and removal.** Delete chat-specific migrations, seeders, models (Conversation, Message), events (MessageSent, TypingStarted, TypingStopped, presence), controllers (`ChatController` endpoints), routes (REST + broadcasting), and any Echo bootstrapping (`realtime.ts`, Echo providers). Remove associated UI components, hooks, and contexts after cataloging references.
2. **Bootstrap Firebase foundation.** Add `src/config/firebase.ts`, ensure environment variables exist for each Firebase key, and document how the backend issues Firebase custom tokens using the existing JWT session so clients never manage a second auth flow.
3. **Define booking-aware data contracts.** Under `src/types/chat.ts`, codify `BookingChatRoom`, `BookingChatMessage`, typing/presence shapes, and participant metadata. Each chat room maps 1:1 with a booking (guest vs host roles), storing booking ID, listing info, and participant IDs for quick filtering.
4. **Implement Firebase chat service.** Create a `chatService.ts` modeled after the reference implementation but extended for booking context: room creation ensures a booking room exists, messages live under `bookingChats/{bookingId}/messages`, a `typing` branch tracks active typers, and metadata keeps `lastMessage`, `lastActivity`, unread counters, and pinned booking details. Include helper APIs for optimistic writes, pagination (via `limitToLast`), and presence cleanup.
5. **Rebuild application state.** Replace `ChatContext`/`MultiChatContext` with a single Firebase-driven provider that subscribes to the relevant booking rooms (based on active bookings and user role) and exposes helpers for opening/minimizing chat windows, sending messages, toggling typing, and marking read status directly in Firebase.
6. **Recreate UI layers.** Update `ChatManager`, `ChatLauncher`, `ResponsiveChatDialog`, and companion components to consume the new context. Components should optimistically append outgoing messages, reflect live typing/presence state from Firebase listeners, and keep responsive behaviors (desktop vs tablet vs mobile) intact without referencing Echo utilities.
7. **Quality gates and cleanup.** Remove unused dependencies (Pusher, Echo, Laravel broadcasting configs), add Firebase typings, and craft integration tests or E2E flows ensuring a booking owner and guest can exchange messages, see typing indicators, and watch unread badges update in real time. Document manual migration steps (dropping old tables) and rollback plans.

### Further Considerations
1. **Booking participants clarified:** Every room is keyed by booking ID and always includes exactly two rolesâ€”`guest` (traveler) and `host` (listing owner). Metadata must store both user IDs and roles so authorization remains explicit when filtering rooms.
2. **Authentication alignment:** Continue issuing and validating the existing backend JWT. The backend will mint Firebase custom tokens based on that JWT so clients authenticate once yet gain Firebase access scoped to their user ID/role.
3. **Data migration strategy:** Drop all database tables, pivots, and caches associated with the retired chat system after verifying nothing else references them. Only chat-affiliated tables (e.g., conversations, messages, related events) are removed; no archival export is required because Firebase becomes the sole source of truth.
